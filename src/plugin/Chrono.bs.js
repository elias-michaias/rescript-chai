// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Plugin from "../Plugin.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function create(initialModel, setSnapshot) {
  var history = {
    contents: [initialModel]
  };
  var index = {
    contents: 0
  };
  var push = function (m) {
    if (index.contents < (history.contents.length - 1 | 0)) {
      history.contents = Belt_Array.slice(history.contents, 0, index.contents + 1 | 0);
    }
    history.contents = Belt_Array.concat(history.contents, [m]);
    index.contents = history.contents.length - 1 | 0;
  };
  var getSnapshot = function (idx) {
    if (idx < 0 || idx >= history.contents.length) {
      return ;
    } else {
      return Belt_Array.get(history.contents, idx);
    }
  };
  var undo = function () {
    if (index.contents <= 0) {
      return ;
    }
    index.contents = index.contents - 1 | 0;
    var s = getSnapshot(index.contents);
    if (s !== undefined) {
      return setSnapshot(Caml_option.valFromOption(s));
    }
    
  };
  var redo = function () {
    if (index.contents >= (history.contents.length - 1 | 0)) {
      return ;
    }
    index.contents = index.contents + 1 | 0;
    var s = getSnapshot(index.contents);
    if (s !== undefined) {
      return setSnapshot(Caml_option.valFromOption(s));
    }
    
  };
  var $$goto = function (idx) {
    if (idx < 0 || idx >= history.contents.length) {
      return ;
    }
    index.contents = idx;
    var s = getSnapshot(idx);
    if (s !== undefined) {
      return setSnapshot(Caml_option.valFromOption(s));
    }
    
  };
  var clear = function () {
    history.contents = [initialModel];
    index.contents = 0;
  };
  var reset = function () {
    setSnapshot(initialModel);
  };
  var dispose = function () {
    clear();
  };
  return {
          history: history,
          index: index,
          push: push,
          undo: undo,
          redo: redo,
          goto: $$goto,
          clear: clear,
          reset: reset,
          getSnapshot: getSnapshot,
          dispose: dispose
        };
}

function createProjected(initialModel, filter, setProjected) {
  var initialSnap = filter(initialModel);
  return create(initialSnap, setProjected);
}

function plugin(innerInit, opts) {
  var builder = function (opts2) {
    var apiFactory = function (ctx) {
      var setSnapshot = function (m) {
        ctx.setRaw(function (curr) {
              return {
                      state: m,
                      dispatch: curr.dispatch,
                      command: curr.command,
                      plugins: curr.plugins
                    };
            });
      };
      var suppressPush = {
        contents: false
      };
      var makeProjected = function (filter, apply) {
        var setProjected = function (snap) {
          var parentNow = ctx.getState().state;
          var updated = apply(snap)(parentNow);
          suppressPush.contents = true;
          setSnapshot(updated);
          suppressPush.contents = false;
        };
        return createProjected(ctx.initialModel, filter, setProjected);
      };
      var match = opts2.filter;
      var match$1 = opts2.apply;
      var baseChrono;
      var exit = 0;
      if (match !== undefined && match$1 !== undefined) {
        baseChrono = makeProjected(match, match$1);
      } else {
        exit = 1;
      }
      if (exit === 1) {
        baseChrono = create(ctx.initialModel, (function (s) {
                suppressPush.contents = true;
                setSnapshot(s);
                suppressPush.contents = false;
              }));
      }
      var unsubscribeRef = {
        contents: undefined
      };
      var subscribeToChanges = function (isProjected, filterFn) {
        var unsub = ctx.subscribe(function (st) {
              if (suppressPush.contents) {
                return ;
              }
              var current = st.state;
              var snap = isProjected && filterFn !== undefined ? filterFn(current) : current;
              baseChrono.push(snap);
            });
        unsubscribeRef.contents = unsub;
      };
      var match$2 = opts2.filter;
      var match$3 = opts2.apply;
      if (match$2 !== undefined && match$3 !== undefined) {
        subscribeToChanges(true, opts2.filter);
      } else {
        subscribeToChanges(false, undefined);
      }
      var max = opts2.max;
      var chronoWithMax;
      if (max !== undefined) {
        var origPush = baseChrono.push;
        var wrappedPush = function (m) {
          origPush(m);
          var len = baseChrono.history.contents.length;
          var keep = max + 1 | 0;
          if (len > keep) {
            baseChrono.history.contents = Belt_Array.slice(baseChrono.history.contents, len - keep | 0, keep);
            baseChrono.index.contents = baseChrono.history.contents.length - 1 | 0;
            return ;
          }
          
        };
        chronoWithMax = {
          history: baseChrono.history,
          index: baseChrono.index,
          push: wrappedPush,
          undo: baseChrono.undo,
          redo: baseChrono.redo,
          goto: baseChrono.goto,
          clear: baseChrono.clear,
          reset: baseChrono.reset,
          getSnapshot: baseChrono.getSnapshot,
          dispose: baseChrono.dispose
        };
      } else {
        chronoWithMax = baseChrono;
      }
      var dispose = function () {
        var u = unsubscribeRef.contents;
        if (u !== undefined) {
          u();
        }
        chronoWithMax.clear();
      };
      return {
              history: chronoWithMax.history,
              index: chronoWithMax.index,
              push: chronoWithMax.push,
              undo: chronoWithMax.undo,
              redo: chronoWithMax.redo,
              goto: chronoWithMax.goto,
              clear: chronoWithMax.clear,
              reset: chronoWithMax.reset,
              getSnapshot: chronoWithMax.getSnapshot,
              dispose: dispose
            };
    };
    var spec_apiFactory = apiFactory;
    var spec = {
      apiFactory: spec_apiFactory
    };
    return $$Plugin.toPluginSpec("chrono", spec);
  };
  var wrapper = $$Plugin.make(builder)(opts);
  return wrapper(innerInit);
}

function get(store) {
  var p = $$Plugin.get(store, "chrono");
  if (p !== undefined) {
    return Caml_option.valFromOption(p);
  }
  
}

export {
  create ,
  createProjected ,
  plugin ,
  get ,
}
/* No side effect */
