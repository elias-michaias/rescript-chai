// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Connection from "./utils/Connection.bs.js";

function listen(cond, opts) {
  if (!cond) {
    return ;
  }
  var keyFn = function (_m) {
    return "ws:" + opts.url;
  };
  return {
          key: keyFn,
          start: (function (dispatch, getModel, startCancel) {
              var cleanupRef = {
                contents: undefined
              };
              var wrapped = function (raw) {
                var m = getModel();
                var shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
                if (!shouldCancelStart) {
                  return dispatch(opts.cons(raw));
                }
                var c = cleanupRef.contents;
                if (c !== undefined) {
                  return c();
                }
                
              };
              var cleanup = Connection.Manager.addListener(opts.url, wrapped, undefined);
              cleanupRef.contents = cleanup;
              return function () {
                var c = cleanupRef.contents;
                if (c !== undefined) {
                  return c();
                }
                
              };
            })
        };
}

var $$WebSocket = {
  listen: listen
};

function every(cond, opts) {
  if (!cond) {
    return ;
  }
  var keyFn = function (_m) {
    return "time:" + String(opts.interval);
  };
  return {
          key: keyFn,
          start: (function (dispatch, getModel, startCancel) {
              var idRef = {
                contents: 0
              };
              var timerCallback = function () {
                var m = getModel();
                var shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
                if (shouldCancelStart) {
                  clearInterval(idRef.contents);
                  return ;
                } else {
                  return dispatch(opts.cons());
                }
              };
              var id = setInterval(timerCallback, opts.interval);
              idRef.contents = id;
              return function () {
                clearInterval(idRef.contents);
              };
            })
        };
}

var Time = {
  every: every
};

function on(cond, opts) {
  if (!cond) {
    return ;
  }
  var keyFn = function (_m) {
    return "event:" + opts.on;
  };
  return {
          key: keyFn,
          start: (function (dispatch, getModel, startCancel) {
              var cleanupRef = {
                contents: undefined
              };
              var handler = function ($$event) {
                var m = getModel();
                var shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
                if (!shouldCancelStart) {
                  return dispatch(opts.cons($$event));
                }
                var c = cleanupRef.contents;
                if (c !== undefined) {
                  return c();
                }
                
              };
              var $$window = window;
              $$window.addEventListener(opts.on, handler);
              cleanupRef.contents = (function () {
                  $$window.removeEventListener(opts.on, handler);
                });
              return function () {
                var c = cleanupRef.contents;
                if (c !== undefined) {
                  return c();
                }
                
              };
            })
        };
}

var Events = {
  on: on
};

var Browser = {
  Events: Events
};

export {
  $$WebSocket ,
  Time ,
  Browser ,
}
/* No side effect */
