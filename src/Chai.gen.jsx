// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Zustand from "zustand";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Middleware from "zustand/middleware";

function select(store, selector) {
  return Zustand.useStore(store, storeState => selector(storeState.state));
}

function makeFilteredStore(origStore, filterOpt, infuseOpt) {
  let getState = () => {
    let s = origStore.getState();
    let statePart = filterOpt !== undefined ? filterOpt(s.state) : s.state;
    let dispatchPart = infuseOpt !== undefined ? subMsg => s.dispatch(infuseOpt(subMsg)) : subMsg => s.dispatch(subMsg);
    return {
      state: statePart,
      dispatch: dispatchPart,
      command: s.command
    };
  };
  let subscribe = listener => origStore.subscribe(s => {
    let statePart = filterOpt !== undefined ? filterOpt(s.state) : s.state;
    let dispatchPart = infuseOpt !== undefined ? subMsg => s.dispatch(infuseOpt(subMsg)) : subMsg => s.dispatch(subMsg);
    listener({
      state: statePart,
      dispatch: dispatchPart,
      command: s.command
    });
  });
  return {
    getState: getState,
    subscribe: subscribe
  };
}

function brew(config) {
  let storeRef = {
    contents: undefined
  };
  let ensureStore = () => {
    let s = storeRef.contents;
    if (s !== undefined) {
      return Primitive_option.valFromOption(s);
    }
    let match = config.init;
    let initialCmd = match[1];
    let initialModel = match[0];
    let initializer = (set, _get, _api) => ({
      state: initialModel,
      dispatch: action => set(current => {
        let match = config.update(current.state, action);
        return {
          state: match[0],
          dispatch: current.dispatch,
          command: match[1]
        };
      }),
      command: initialCmd
    });
    let ext = config.middleware;
    let enhancedInit = ext !== undefined ? ext(initializer) : initializer;
    let s$1 = Zustand.create(enhancedInit);
    let runFn = config.run;
    if (runFn !== undefined) {
      let state0 = s$1.getState();
      let prevCmdRef = {
        contents: state0.command
      };
      runFn(state0.command, state0.dispatch);
      s$1.subscribe(st => {
        if (Primitive_object.notequal(st.command, prevCmdRef.contents)) {
          prevCmdRef.contents = st.command;
          runFn(st.command, st.dispatch);
          return;
        }
      });
    }
    let subsFn = config.subs;
    if (subsFn !== undefined) {
      let getModel = () => s$1.getState().state;
      let prevMapRef = {
        contents: {}
      };
      let syncForModel = (model, dispatch) => {
        let nextRaw = subsFn(model);
        let next = Belt_Array.keepMap(nextRaw, x => x);
        let nextMap = {};
        next.forEach(sub => {
          let key = sub.key(model);
          let oldCleanup = Js_dict.get(prevMapRef.contents, key);
          if (oldCleanup !== undefined) {
            nextMap[key] = oldCleanup;
            return;
          }
          let startCancel = mArg => {
            let raw = subsFn(mArg);
            let nextList = Belt_Array.keepMap(raw, x => x);
            return !nextList.some(s => s.key(mArg) === key);
          };
          let cleanup = sub.start(dispatch, getModel, startCancel);
          nextMap[key] = cleanup;
        });
        Js_dict.entries(prevMapRef.contents).forEach(param => {
          let match = Js_dict.get(nextMap, param[0]);
          if (match !== undefined) {
            return;
          } else {
            return param[1]();
          }
        });
        prevMapRef.contents = nextMap;
      };
      let stateNow = s$1.getState();
      syncForModel(stateNow.state, stateNow.dispatch);
      s$1.subscribe(st => syncForModel(st.state, st.dispatch));
    }
    storeRef.contents = Primitive_option.some(s$1);
    return s$1;
  };
  return () => {
    let store = ensureStore();
    let dispatch = Zustand.useStore(store, st => st.dispatch);
    return [
      store,
      dispatch
    ];
  };
}

function pour(useInstanceHook, opts) {
  return () => {
    let match = useInstanceHook();
    let dispatch = match[1];
    let filtered = makeFilteredStore(match[0], opts.filter, opts.infuse);
    let wrappedDispatch = subMsg => dispatch(opts.infuse(subMsg));
    return [
      filtered,
      wrappedDispatch
    ];
  };
}

function persist(prim0, prim1) {
  return Middleware.persist(prim0, prim1);
}

function devtools(prim0, prim1) {
  return Middleware.devtools(prim0, prim1);
}

export {
  select,
  makeFilteredStore,
  brew,
  pour,
  persist,
  devtools,
}
/* zustand Not a pure module */
