// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Connection from "./utils/Connection.gen.jsx";
import * as IndexedDB_ from "./bindings/IndexedDB_.gen.jsx";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Dom_storage from "@rescript/runtime/lib/es6/Dom_storage.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

async function run(cmds, dispatch, runner) {
  let promises = cmds.map(c => runner(c, dispatch));
  await Promise.all(promises);
}

let Batch = {
  run: run
};

async function run$1(cmd, dispatch) {
  setTimeout(() => dispatch(cmd.msg), cmd.ms);
}

let Delay = {
  run: run$1
};

async function run$2(cmd, dispatch) {
  dispatch(cmd.cons(Date.now()));
}

let Now = {
  run: run$2
};

let Time = {
  Delay: Delay,
  Now: Now
};

async function run$3(cmd) {
  console.log(cmd);
}

let Log = {
  run: run$3
};

async function run$4(cmd, dispatch) {
  let response = await fetch(cmd.url, cmd.req);
  return dispatch(await cmd.cons(response));
}

let Req = {
  run: run$4
};

async function run$5(cmd, dispatch) {
  let response = await fetch(cmd.url, cmd.req);
  let body = await response.json();
  return dispatch(await cmd.cons(body));
}

let Json = {
  run: run$5
};

let Http = {
  Req: Req,
  Json: Json
};

async function run$6(cmd, dispatch) {
  let result;
  try {
    result = Dom_storage.getItem(cmd.key, localStorage);
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      result = undefined;
    } else {
      throw exn;
    }
  }
  return dispatch(cmd.cons(result));
}

let Get = {
  run: run$6
};

async function run$7(_cmd, _dispatch) {
  try {
    return Dom_storage.setItem(_cmd.key, _cmd.value, localStorage);
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return;
    }
    throw exn;
  }
}

let $$Set = {
  run: run$7
};

async function run$8(_cmd, _dispatch) {
  try {
    return Dom_storage.removeItem(_cmd.key, localStorage);
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return;
    }
    throw exn;
  }
}

let Remove = {
  run: run$8
};

async function run$9(_cmd, _dispatch) {
  try {
    localStorage.clear();
    return;
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return;
    }
    throw exn;
  }
}

let Clear = {
  run: run$9
};

let LocalStorage = {
  Get: Get,
  $$Set: $$Set,
  Remove: Remove,
  Clear: Clear
};

async function run$10(cmd, dispatch) {
  try {
    let openRequest = indexedDB.open(cmd.db, 1);
    openRequest.onupgradeneeded = event => {
      let db = event.target.result;
      if (!IndexedDB_.contains(db.objectStoreNames, "keyvalue")) {
        db.createObjectStore(cmd.store);
        return;
      }
    };
    let db = await new Promise((resolve, reject) => {
      openRequest.onsuccess = event => resolve(event.target.result);
      openRequest.onerror = event => reject(event.target.error);
    });
    let transaction = db.transaction(cmd.store, "readonly");
    let store = transaction.objectStore(cmd.store);
    let getRequest = store.get(cmd.key);
    let value = await new Promise((resolve, reject) => {
      getRequest.onsuccess = event => resolve(event.target.result);
      getRequest.onerror = event => reject(event.target.error);
    });
    return dispatch(cmd.cons(value));
  } catch (exn) {
    return dispatch(cmd.cons(undefined));
  }
}

let Get$1 = {
  run: run$10
};

async function run$11(cmd, _dispatch) {
  try {
    let openRequest = indexedDB.open(cmd.db, 1);
    openRequest.onupgradeneeded = event => {
      let db = event.target.result;
      if (!IndexedDB_.contains(db.objectStoreNames, cmd.store)) {
        db.createObjectStore(cmd.store);
        return;
      }
    };
    let db = await new Promise((resolve, reject) => {
      openRequest.onsuccess = event => resolve(event.target.result);
      openRequest.onerror = event => reject(event.target.error);
    });
    let transaction = db.transaction(cmd.store, "readwrite");
    let store = transaction.objectStore(cmd.store);
    store.put(cmd.value, cmd.key);
    return await new Promise((resolve, reject) => {
      transaction.oncomplete = _event => resolve();
      transaction.onerror = event => reject(event.target.error);
    });
  } catch (exn) {
    return;
  }
}

let $$Set$1 = {
  run: run$11
};

async function run$12(cmd, _dispatch) {
  try {
    let openRequest = indexedDB.open(cmd.db, 1);
    openRequest.onupgradeneeded = event => {
      let db = event.target.result;
      if (!IndexedDB_.contains(db.objectStoreNames, cmd.store)) {
        db.createObjectStore(cmd.store);
        return;
      }
    };
    let db = await new Promise((resolve, reject) => {
      openRequest.onsuccess = event => resolve(event.target.result);
      openRequest.onerror = event => reject(event.target.error);
    });
    let transaction = db.transaction(cmd.store, "readwrite");
    let store = transaction.objectStore(cmd.store);
    store.delete(cmd.key);
    return await new Promise((resolve, reject) => {
      transaction.oncomplete = _event => resolve();
      transaction.onerror = event => reject(event.target.error);
    });
  } catch (exn) {
    return;
  }
}

let Remove$1 = {
  run: run$12
};

async function run$13(cmd, _dispatch) {
  try {
    let openRequest = indexedDB.open(cmd.db, 1);
    openRequest.onupgradeneeded = event => {
      let db = event.target.result;
      if (!IndexedDB_.contains(db.objectStoreNames, cmd.store)) {
        db.createObjectStore(cmd.store);
        return;
      }
    };
    let db = await new Promise((resolve, reject) => {
      openRequest.onsuccess = event => resolve(event.target.result);
      openRequest.onerror = event => reject(event.target.error);
    });
    let transaction = db.transaction(cmd.store, "readwrite");
    let store = transaction.objectStore(cmd.store);
    store.clear();
    return await new Promise((resolve, reject) => {
      transaction.oncomplete = _event => resolve();
      transaction.onerror = event => reject(event.target.error);
    });
  } catch (exn) {
    return;
  }
}

let Clear$1 = {
  run: run$13
};

let IndexedDB = {
  Get: Get$1,
  $$Set: $$Set$1,
  Remove: Remove$1,
  Clear: Clear$1
};

async function run$14(cmd, _dispatch) {
  let match = cmd.stringify;
  if (match !== undefined && match) {
    return Connection.Manager.send(cmd.url, cmd.data, true);
  }
  return Connection.Manager.send(cmd.url, cmd.data, false);
}

let WebSocket = {
  run: run$14
};

async function run$15(cmds, runner, dispatch) {
  let len = cmds.length;
  let _loop = async i => {
    if (i < len) {
      await runner(cmds[i], dispatch);
      await _loop(i + 1 | 0);
    }
    return await _loop(0);
  };
}

let Sequence = {
  run: run$15
};

export {
  Batch,
  Time,
  Log,
  Http,
  LocalStorage,
  IndexedDB,
  WebSocket,
  Sequence,
}
/* No side effect */
