// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Connection from "./utils/Connection.gen.jsx";

function listen(cond, opts) {
  if (!cond) {
    return;
  }
  let keyFn = _m => "ws:" + opts.url;
  return {
    key: keyFn,
    start: (dispatch, getModel, startCancel) => {
      let cleanupRef = {
        contents: undefined
      };
      let wrapped = raw => {
        let m = getModel();
        let shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
        if (!shouldCancelStart) {
          return dispatch(opts.cons(raw));
        }
        let c = cleanupRef.contents;
        if (c !== undefined) {
          return c();
        }
      };
      let cleanup = Connection.Manager.addListener(opts.url, wrapped, undefined);
      cleanupRef.contents = cleanup;
      return () => {
        let c = cleanupRef.contents;
        if (c !== undefined) {
          return c();
        }
      };
    }
  };
}

let WebSocket = {
  listen: listen
};

function every(cond, opts) {
  if (!cond) {
    return;
  }
  let keyFn = _m => "time:" + String(opts.interval);
  return {
    key: keyFn,
    start: (dispatch, getModel, startCancel) => {
      let idRef = {
        contents: 0
      };
      let timerCallback = () => {
        let m = getModel();
        let shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
        if (shouldCancelStart) {
          clearInterval(idRef.contents);
          return;
        } else {
          return dispatch(opts.cons());
        }
      };
      let id = setInterval(timerCallback, opts.interval);
      idRef.contents = id;
      return () => {
        clearInterval(idRef.contents);
      };
    }
  };
}

let Time = {
  every: every
};

function on(cond, opts) {
  if (!cond) {
    return;
  }
  let keyFn = _m => "event:" + opts.on;
  return {
    key: keyFn,
    start: (dispatch, getModel, startCancel) => {
      let cleanupRef = {
        contents: undefined
      };
      let handler = event => {
        let m = getModel();
        let shouldCancelStart = startCancel !== undefined ? startCancel(m) : false;
        if (!shouldCancelStart) {
          return dispatch(opts.cons(event));
        }
        let c = cleanupRef.contents;
        if (c !== undefined) {
          return c();
        }
      };
      let window = window;
      window.addEventListener(opts.on, handler);
      cleanupRef.contents = () => window.removeEventListener(opts.on, handler);
      return () => {
        let c = cleanupRef.contents;
        if (c !== undefined) {
          return c();
        }
      };
    }
  };
}

let Events = {
  on: on
};

let Browser = {
  Events: Events
};

export {
  WebSocket,
  Time,
  Browser,
}
/* No side effect */
