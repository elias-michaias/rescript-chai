// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Chrono from "./utils/Chrono.bs.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Zustand from "zustand";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ReactTracked from "react-tracked";
import * as Middleware from "zustand/middleware";

function select(store, selector) {
  return Zustand.useStore(store, (function (storeState) {
                return selector(storeState.state);
              }));
}

function makeFilteredStore(origStore, filterOpt, infuseOpt) {
  var getState = function () {
    var s = origStore.getState();
    var statePart = filterOpt(s.state);
    var dispatchPart = function (subMsg) {
      s.dispatch(infuseOpt(subMsg));
    };
    return {
            state: statePart,
            dispatch: dispatchPart,
            command: s.command,
            chrono: s.chrono
          };
  };
  var subscribe = function (listener) {
    return origStore.subscribe(function (s) {
                var statePart = filterOpt(s.state);
                var dispatchPart = function (subMsg) {
                  s.dispatch(infuseOpt(subMsg));
                };
                listener({
                      state: statePart,
                      dispatch: dispatchPart,
                      command: s.command,
                      chrono: s.chrono
                    });
              });
  };
  return {
          getState: getState,
          subscribe: subscribe
        };
}

function track(useInstance) {
  return function (init) {
    var triple = init !== undefined ? useInstance(init) : useInstance(undefined);
    var rawStore = triple[2];
    var dispatch = triple[1];
    var useStateFromStore = function (selector) {
      return Zustand.useStore(rawStore, (function (storeState) {
                    return selector(storeState.state);
                  }));
    };
    var useTracked = ReactTracked.createTrackedSelector(useStateFromStore);
    var state = useTracked();
    if (init !== undefined) {
      React.useEffect((function () {
              dispatch(init());
            }), []);
    }
    return [
            state,
            dispatch,
            rawStore
          ];
  };
}

function brew(config) {
  var storeRef = {
    contents: undefined
  };
  var ensureStore = function () {
    var s = storeRef.contents;
    if (s !== undefined) {
      return Caml_option.valFromOption(s);
    }
    var match = config.init;
    var initialCmd = match[1];
    var initialModel = match[0];
    var initializer = function (set, _get, _api) {
      var setSnapshotModel = function (m) {
        set(function (curr) {
              return {
                      state: m,
                      dispatch: curr.dispatch,
                      command: curr.command,
                      chrono: curr.chrono
                    };
            });
      };
      var opts = config.opts;
      var chronoEnabled;
      if (opts !== undefined) {
        var c = opts.chrono;
        if (c !== undefined) {
          var b = c.enabled;
          chronoEnabled = b !== undefined ? b : false;
        } else {
          chronoEnabled = false;
        }
      } else {
        chronoEnabled = false;
      }
      var opts$1 = config.opts;
      var chronoMax;
      if (opts$1 !== undefined) {
        var c$1 = opts$1.chrono;
        chronoMax = c$1 !== undefined ? c$1.max : undefined;
      } else {
        chronoMax = undefined;
      }
      var chronoIsProjectedRef = {
        contents: false
      };
      var chronoFilterRawRef = {
        contents: undefined
      };
      var chronoApplyRawRef;
      var opts$2 = config.opts;
      var chronoInstance;
      if (opts$2 !== undefined) {
        var c$2 = opts$2.chrono;
        if (c$2 !== undefined) {
          var match = c$2.filter;
          var match$1 = c$2.apply;
          var exit = 0;
          if (match !== undefined && match$1 !== undefined) {
            chronoIsProjectedRef.contents = true;
            chronoFilterRawRef.contents = Caml_option.some(match);
            chronoApplyRawRef = Caml_option.some(match$1);
            var setProjected = function (snap) {
              set(function (curr) {
                    var parentNow = curr.state;
                    var updatedParent = match$1(snap)(parentNow);
                    return {
                            state: updatedParent,
                            dispatch: curr.dispatch,
                            command: curr.command,
                            chrono: curr.chrono
                          };
                  });
            };
            chronoInstance = Chrono.createProjected(initialModel, match, setProjected);
          } else {
            exit = 1;
          }
          if (exit === 1) {
            chronoInstance = chronoEnabled ? Chrono.create(initialModel, setSnapshotModel) : Chrono.noop(initialModel, setSnapshotModel);
          }
          
        } else {
          chronoInstance = chronoEnabled ? Chrono.create(initialModel, setSnapshotModel) : Chrono.noop(initialModel, setSnapshotModel);
        }
      } else {
        chronoInstance = chronoEnabled ? Chrono.create(initialModel, setSnapshotModel) : Chrono.noop(initialModel, setSnapshotModel);
      }
      return {
              state: initialModel,
              dispatch: (function (action) {
                  set(function (current) {
                        var match = config.update(current.state, action);
                        var newState = match[0];
                        if (chronoIsProjectedRef.contents) {
                          var rawF = chronoFilterRawRef.contents;
                          if (rawF !== undefined) {
                            chronoInstance.push(Caml_option.valFromOption(rawF)(newState));
                          } else {
                            chronoInstance.push(newState);
                          }
                        } else {
                          chronoInstance.push(newState);
                        }
                        if (chronoMax !== undefined) {
                          var keep = chronoMax + 1 | 0;
                          var len = chronoInstance.history.contents.length;
                          if (len > keep) {
                            chronoInstance.history.contents = Belt_Array.slice(chronoInstance.history.contents, len - keep | 0, keep);
                            chronoInstance.index.contents = chronoInstance.history.contents.length - 1 | 0;
                          }
                          
                        }
                        return {
                                state: newState,
                                dispatch: current.dispatch,
                                command: match[1],
                                chrono: current.chrono
                              };
                      });
                }),
              command: initialCmd,
              chrono: chronoInstance
            };
    };
    var ext = config.middleware;
    var enhancedInit = ext !== undefined ? ext(initializer) : initializer;
    var s$1 = Zustand.create(enhancedInit);
    var runFn = config.run;
    if (runFn !== undefined) {
      var state0 = s$1.getState();
      var prevCmdRef = {
        contents: state0.command
      };
      runFn(state0.command, state0.dispatch);
      s$1.subscribe(function (st) {
            if (Caml_obj.notequal(st.command, prevCmdRef.contents)) {
              prevCmdRef.contents = st.command;
              runFn(st.command, st.dispatch);
              return ;
            }
            
          });
    }
    var subsFn = config.subs;
    if (subsFn !== undefined) {
      var getModel = function () {
        return s$1.getState().state;
      };
      var prevMapRef = {
        contents: {}
      };
      var syncForModel = function (model, dispatch) {
        var nextRaw = subsFn(model);
        var next = Belt_Array.keepMap(nextRaw, (function (x) {
                return x;
              }));
        var nextMap = {};
        next.forEach(function (sub) {
              var key = sub.key(model);
              var oldCleanup = Js_dict.get(prevMapRef.contents, key);
              if (oldCleanup !== undefined) {
                nextMap[key] = oldCleanup;
                return ;
              }
              var startCancel = function (mArg) {
                var raw = subsFn(mArg);
                var nextList = Belt_Array.keepMap(raw, (function (x) {
                        return x;
                      }));
                return !nextList.some(function (s) {
                            return s.key(mArg) === key;
                          });
              };
              var cleanup = sub.start(dispatch, getModel, startCancel);
              nextMap[key] = cleanup;
            });
        Js_dict.entries(prevMapRef.contents).forEach(function (param) {
              var match = Js_dict.get(nextMap, param[0]);
              if (match !== undefined) {
                return ;
              } else {
                return param[1]();
              }
            });
        prevMapRef.contents = nextMap;
      };
      var stateNow = s$1.getState();
      syncForModel(stateNow.state, stateNow.dispatch);
      s$1.subscribe(function (st) {
            syncForModel(st.state, st.dispatch);
          });
    }
    storeRef.contents = Caml_option.some(s$1);
    return s$1;
  };
  var rawUseInstance = function (init) {
    var s = ensureStore();
    var dispatch = Zustand.useStore(s, (function (st) {
            return st.dispatch;
          }));
    return [
            s,
            dispatch,
            s
          ];
  };
  return track(rawUseInstance);
}

function pour(useInstanceHook, opts) {
  return function (init) {
    var match = useInstanceHook(undefined);
    var rawStore = match[2];
    var parentDispatch = match[1];
    var useStateFromStore = function (selector) {
      return Zustand.useStore(rawStore, (function (storeState) {
                    return selector(opts.filter(storeState.state));
                  }));
    };
    var useTracked = ReactTracked.createTrackedSelector(useStateFromStore);
    var state = useTracked();
    var dispatch = function (subMsg) {
      parentDispatch(opts.infuse(subMsg));
    };
    if (init !== undefined) {
      React.useEffect((function () {
              parentDispatch(opts.infuse(init()));
            }), []);
    }
    return [
            state,
            dispatch,
            rawStore
          ];
  };
}

function persist(prim0, prim1) {
  return Middleware.persist(prim0, prim1);
}

function devtools(prim0, prim1) {
  return Middleware.devtools(prim0, prim1);
}

function chrono(rawStore) {
  return rawStore.getState().chrono;
}

export {
  select ,
  makeFilteredStore ,
  track ,
  brew ,
  pour ,
  persist ,
  devtools ,
  chrono ,
}
/* react Not a pure module */
